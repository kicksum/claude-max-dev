// conversation.service.js
// Service layer for conversation and message operations
// Updated: 2025-10-29 - Added model_used tracking

const { pool } = require('../config/database');

/**
 * Get all conversations ordered by most recently updated
 */
async function getAllConversations() {
  const result = await pool.query(`
    SELECT 
      c.*,
      COUNT(m.id) as message_count
    FROM conversations c
    LEFT JOIN messages m ON c.id = m.conversation_id
    GROUP BY c.id
    ORDER BY c.updated_at DESC
  `);
  return result.rows;
}

/**
 * Get a single conversation by ID
 */
async function getConversation(id) {
  const result = await pool.query(
    'SELECT * FROM conversations WHERE id = $1',
    [id]
  );
  return result.rows[0];
}

/**
 * Create a new conversation
 */
async function createConversation(title = 'New Chat', model = 'claude-sonnet-4-20250514') {
  const result = await pool.query(
    `INSERT INTO conversations (title, model) 
     VALUES ($1, $2) 
     RETURNING *`,
    [title, model]
  );
  return result.rows[0];
}

/**
 * Update a conversation (title, model, project_id, etc.)
 */
async function updateConversation(id, updates) {
  const allowedFields = ['title', 'model', 'project_id'];
  const setClause = [];
  const values = [];
  let paramIndex = 1;

  for (const [key, value] of Object.entries(updates)) {
    if (allowedFields.includes(key)) {
      setClause.push(`${key} = $${paramIndex}`);
      values.push(value);
      paramIndex++;
    }
  }

  if (setClause.length === 0) {
    throw new Error('No valid fields to update');
  }

  // Always update the updated_at timestamp
  setClause.push(`updated_at = NOW()`);
  values.push(id);

  const query = `
    UPDATE conversations 
    SET ${setClause.join(', ')}
    WHERE id = $${paramIndex}
    RETURNING *
  `;

  const result = await pool.query(query, values);
  return result.rows[0];
}

/**
 * Delete a conversation and all its messages
 */
async function deleteConversation(id) {
  await pool.query('DELETE FROM conversations WHERE id = $1', [id]);
}

/**
 * Get all messages for a conversation
 */
async function getMessages(conversationId) {
  const result = await pool.query(
    `SELECT * FROM messages 
     WHERE conversation_id = $1 
     ORDER BY created_at ASC`,
    [conversationId]
  );
  return result.rows;
}

/**
 * Save a message to the database
 * @param {string} conversationId - Conversation ID
 * @param {string} role - 'user' or 'assistant'
 * @param {string} content - Message content
 * @param {number} cost - Cost in dollars (0 for user messages)
 * @param {number} inputTokens - Input tokens (0 for user messages)
 * @param {number} outputTokens - Output tokens (0 for user messages)
 * @param {string|null} modelUsed - Model identifier (null for user messages, required for assistant)
 */
async function saveMessage(
  conversationId,
  role,
  content,
  cost = 0,
  inputTokens = 0,
  outputTokens = 0,
  modelUsed = null
) {
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');

    // Insert message with model tracking
    const messageResult = await client.query(
      `INSERT INTO messages (conversation_id, role, content, cost, input_tokens, output_tokens, model_used)
       VALUES ($1, $2, $3, $4, $5, $6, $7)
       RETURNING *`,
      [conversationId, role, content, cost, inputTokens, outputTokens, modelUsed]
    );

    const message = messageResult.rows[0];

    // Update conversation totals and timestamp
    await client.query(
      `UPDATE conversations 
       SET total_cost = total_cost + $1,
           total_input_tokens = total_input_tokens + $2,
           total_output_tokens = total_output_tokens + $3,
           updated_at = NOW()
       WHERE id = $4`,
      [cost, inputTokens, outputTokens, conversationId]
    );

    await client.query('COMMIT');
    return message;
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}

module.exports = {
  getAllConversations,
  getConversation,
  createConversation,
  updateConversation,
  deleteConversation,
  getMessages,
  saveMessage
};

const express = require('express');
const router = express.Router();
const conversationService = require('../services/conversation.service');
const claudeService = require('../services/claude.service');
const pool = require('../config/database');

// Get all conversations
router.get('/', async (req, res) => {
  try {
    const conversations = await conversationService.getAllConversations();
    res.json(conversations);
  } catch (error) {
    console.error('Error fetching conversations:', error);
    res.status(500).json({ error: error.message });
  }
});

// Create new conversation
router.post('/', async (req, res) => {
  try {
    const { title, model } = req.body;
    const conversation = await conversationService.createConversation(title || 'New Chat', model);
    res.json(conversation);
  } catch (error) {
    console.error('Error creating conversation:', error);
    res.status(500).json({ error: error.message });
  }
});

// Update conversation title
router.put('/:id/title', async (req, res) => {
  try {
    const { id } = req.params;
    const { title } = req.body;
    
    if (!title || !title.trim()) {
      return res.status(400).json({ error: 'Title is required' });
    }
    
    const conversation = await conversationService.updateConversation(id, { title: title.trim() });
    res.json(conversation);
  } catch (error) {
    console.error('Error updating conversation title:', error);
    res.status(500).json({ error: error.message });
  }
});

// Update conversation (including project assignment)
router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;
    const conversation = await conversationService.updateConversation(id, updates);
    res.json(conversation);
  } catch (error) {
    console.error('Error updating conversation:', error);
    res.status(500).json({ error: error.message });
  }
});

// PATCH route for compatibility (same as PUT)
router.patch('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;
    const conversation = await conversationService.updateConversation(id, updates);
    res.json(conversation);
  } catch (error) {
    console.error('Error updating conversation:', error);
    res.status(500).json({ error: error.message });
  }
});

// Delete conversation
router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    await conversationService.deleteConversation(id);
    res.json({ success: true });
  } catch (error) {
    console.error('Error deleting conversation:', error);
    res.status(500).json({ error: error.message });
  }
});

// Generate title from message content
router.post('/:id/generate-title', async (req, res) => {
  try {
    const { id } = req.params;
    const { content } = req.body;
    
    if (!content) {
      return res.status(400).json({ error: 'Content is required' });
    }
    
    // Use Claude to generate a short, descriptive title
    const titlePrompt = `Generate a very short, concise title (3-6 words max) for a conversation that starts with: "${content.substring(0, 200)}..."

Reply with ONLY the title, no quotes, no explanation.`;
    
    const title = await claudeService.generateTitle(titlePrompt);
    
    // Update the conversation with the new title
    const conversation = await conversationService.updateConversation(id, { title });
    
    res.json(conversation);
  } catch (error) {
    console.error('Error generating title:', error);
    res.status(500).json({ error: error.message });
  }
});

// Export conversation as Markdown or JSON
router.get('/:id/export', async (req, res) => {
  try {
    const { id } = req.params;
    const format = req.query.format || 'markdown';

    // Get conversation with metadata
    const convResult = await pool.query(
      'SELECT * FROM conversations WHERE id = $1',
      [id]
    );

    if (convResult.rows.length === 0) {
      return res.status(404).json({ error: 'Conversation not found' });
    }

    const conversation = convResult.rows[0];

    // Get all messages
    const messagesResult = await pool.query(
      'SELECT * FROM messages WHERE conversation_id = $1 ORDER BY created_at ASC',
      [id]
    );

    const messages = messagesResult.rows;

    if (format === 'json') {
      // JSON Export
      const jsonData = {
        conversation: {
          id: conversation.id,
          title: conversation.title,
          model: conversation.model,
          created_at: conversation.created_at,
          updated_at: conversation.updated_at,
          total_cost: Number(conversation.total_cost),
          total_input_tokens: conversation.total_input_tokens,
          total_output_tokens: conversation.total_output_tokens,
          project_id: conversation.project_id
        },
        messages: messages.map(msg => ({
          id: msg.id,
          role: msg.role,
          content: msg.content,
          created_at: msg.created_at,
          cost: Number(msg.cost),
          input_tokens: msg.input_tokens,
          output_tokens: msg.output_tokens
        })),
        exported_at: new Date().toISOString(),
        export_version: '1.0'
      };

      const filename = `${conversation.title.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.json`;
      
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.json(jsonData);

    } else {
      // Markdown Export
      let markdown = '';
      
      // Title and metadata
      markdown += `# ${conversation.title}\n\n`;
      markdown += `**Model:** ${conversation.model || 'N/A'}\n`;
      markdown += `**Created:** ${new Date(conversation.created_at).toLocaleString()}\n`;
      markdown += `**Updated:** ${new Date(conversation.updated_at).toLocaleString()}\n`;
      markdown += `**Total Cost:** $${Number(conversation.total_cost).toFixed(4)}\n`;
      markdown += `**Total Tokens:** ${(conversation.total_input_tokens + conversation.total_output_tokens).toLocaleString()} (${conversation.total_input_tokens.toLocaleString()} in, ${conversation.total_output_tokens.toLocaleString()} out)\n\n`;
      markdown += '---\n\n';

      // Messages
      messages.forEach((msg, index) => {
        const role = msg.role === 'user' ? 'ðŸ‘¤ User' : 'ðŸ¤– Assistant';
        const timestamp = new Date(msg.created_at).toLocaleString();
        
        markdown += `## ${role} - ${timestamp}\n\n`;
        markdown += `${msg.content}\n\n`;
        
        if (msg.cost > 0) {
          markdown += `*Cost: $${Number(msg.cost).toFixed(4)} | Tokens: ${msg.input_tokens + msg.output_tokens} (${msg.input_tokens} in, ${msg.output_tokens} out)*\n\n`;
        }
        
        markdown += '---\n\n';
      });

      const filename = `${conversation.title.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.md`;
      
      res.setHeader('Content-Type', 'text/markdown');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(markdown);
    }

  } catch (error) {
    console.error('Export error:', error);
    res.status(500).json({ error: 'Failed to export conversation' });
  }
 });
 // Bulk export all conversations in a project as ZIP
 router.get('/project/:projectId/export', async (req, res) => {
   try {
     const { projectId } = req.params;
     const format = req.query.format || 'markdown';
     
     const archiver = require('archiver');
     
     // Get project info
     const projectResult = await pool.query(
       'SELECT * FROM projects WHERE id = $1',
       [projectId]
     );
     
     if (projectResult.rows.length === 0) {
       return res.status(404).json({ error: 'Project not found' });
     }
     
     const project = projectResult.rows[0];
     
     // Get all conversations in this project
     const convsResult = await pool.query(
       'SELECT * FROM conversations WHERE project_id = $1 ORDER BY created_at DESC',
       [projectId]
     );
     
     if (convsResult.rows.length === 0) {
       return res.status(404).json({ error: 'No conversations in this project' });
     }
     
     const conversations = convsResult.rows;
     
     // Create ZIP archive
     const archive = archiver('zip', {
       zlib: { level: 9 }
     });
     
     const projectName = project.name.replace(/[^a-z0-9]/gi, '_');
     const timestamp = new Date().toISOString().split('T')[0];
     const zipFilename = `${projectName}_export_${timestamp}.zip`;
     
     res.setHeader('Content-Type', 'application/zip');
     res.setHeader('Content-Disposition', `attachment; filename="${zipFilename}"`);
     
     archive.pipe(res);
     
     // Add each conversation to the ZIP
     for (const conv of conversations) {
       // Get messages for this conversation
       const messagesResult = await pool.query(
         'SELECT * FROM messages WHERE conversation_id = $1 ORDER BY created_at ASC',
         [conv.id]
       );
       
       const messages = messagesResult.rows;
       
       if (format === 'json') {
         // JSON format
         const jsonData = {
           conversation: {
             id: conv.id,
             title: conv.title,
             model: conv.model,
             created_at: conv.created_at,
             updated_at: conv.updated_at,
             total_cost: Number(conv.total_cost),
             total_input_tokens: conv.total_input_tokens,
             total_output_tokens: conv.total_output_tokens,
             project_id: conv.project_id
           },
           messages: messages.map(msg => ({
             id: msg.id,
             role: msg.role,
             content: msg.content,
             created_at: msg.created_at,
             cost: Number(msg.cost),
             input_tokens: msg.input_tokens,
             output_tokens: msg.output_tokens
           })),
           exported_at: new Date().toISOString(),
           export_version: '1.0'
         };
         
         const filename = `${conv.title.replace(/[^a-z0-9]/gi, '_')}.json`;
         archive.append(JSON.stringify(jsonData, null, 2), { name: filename });
         
       } else {
         // Markdown format
         let markdown = '';
         
         markdown += `# ${conv.title}\n\n`;
         markdown += `**Model:** ${conv.model || 'N/A'}\n`;
         markdown += `**Created:** ${new Date(conv.created_at).toLocaleString()}\n`;
         markdown += `**Updated:** ${new Date(conv.updated_at).toLocaleString()}\n`;
         markdown += `**Total Cost:** $${Number(conv.total_cost).toFixed(4)}\n`;
         markdown += `**Total Tokens:** ${(conv.total_input_tokens + conv.total_output_tokens).toLocaleString()} (${conv.total_input_tokens.toLocaleString()} in, ${conv.total_output_tokens.toLocaleString()} out)\n\n`;
         markdown += '---\n\n';
         
         messages.forEach((msg) => {
           const role = msg.role === 'user' ? 'ðŸ‘¤ User' : 'ðŸ¤– Assistant';
           const timestamp = new Date(msg.created_at).toLocaleString();
           
           markdown += `## ${role} - ${timestamp}\n\n`;
           markdown += `${msg.content}\n\n`;
           
           if (msg.cost > 0) {
             markdown += `*Cost: $${Number(msg.cost).toFixed(4)} | Tokens: ${msg.input_tokens + msg.output_tokens} (${msg.input_tokens} in, ${msg.output_tokens} out)*\n\n`;
           }
           
           markdown += '---\n\n';
         });
         
         const filename = `${conv.title.replace(/[^a-z0-9]/gi, '_')}.md`;
         archive.append(markdown, { name: filename });
       }
     }
     
     // Add a README
     const readme = `# ${project.name} - Export\n\n` +
       `Exported: ${new Date().toLocaleString()}\n` +
       `Total Conversations: ${conversations.length}\n` +
       `Format: ${format}\n\n` +
       `## Conversations\n\n` +
       conversations.map((c, i) => `${i + 1}. ${c.title}`).join('\n');
     
     archive.append(readme, { name: 'README.md' });
     
     await archive.finalize();
     
   } catch (error) {
     console.error('Bulk export error:', error);
     res.status(500).json({ error: 'Failed to export project' });
   }
 });
// Generate global usage report
router.get('/report/usage', async (req, res) => {
  try {
    // Get all conversations with stats
    const convsResult = await pool.query(`
      SELECT 
        c.*,
        p.name as project_name,
        p.icon as project_icon
      FROM conversations c
      LEFT JOIN projects p ON c.project_id = p.id
      ORDER BY c.total_cost DESC
    `);
    
    const conversations = convsResult.rows;
    
    // Calculate totals
    const totalConversations = conversations.length;
    const totalCost = conversations.reduce((sum, c) => sum + Number(c.total_cost), 0);
    const totalInputTokens = conversations.reduce((sum, c) => sum + c.total_input_tokens, 0);
    const totalOutputTokens = conversations.reduce((sum, c) => sum + c.total_output_tokens, 0);
    
    // Get total messages count
    const messagesResult = await pool.query('SELECT COUNT(*) as count FROM messages');
    const totalMessages = parseInt(messagesResult.rows[0].count);
    
    // Group by model
    const byModel = {};
    conversations.forEach(conv => {
      const model = conv.model || 'Unknown';
      if (!byModel[model]) {
        byModel[model] = {
          conversations: 0,
          cost: 0,
          inputTokens: 0,
          outputTokens: 0
        };
      }
      byModel[model].conversations++;
      byModel[model].cost += Number(conv.total_cost);
      byModel[model].inputTokens += conv.total_input_tokens;
      byModel[model].outputTokens += conv.total_output_tokens;
    });
    
    // Group by project
    const byProject = {};
    conversations.forEach(conv => {
      const projectKey = conv.project_id || 'uncategorized';
      const projectName = conv.project_name || 'Uncategorized';
      const projectIcon = conv.project_icon || 'ðŸ“‚';
      
      if (!byProject[projectKey]) {
        byProject[projectKey] = {
          name: projectName,
          icon: projectIcon,
          conversations: 0,
          cost: 0,
          tokens: 0
        };
      }
      byProject[projectKey].conversations++;
      byProject[projectKey].cost += Number(conv.total_cost);
      byProject[projectKey].tokens += conv.total_input_tokens + conv.total_output_tokens;
    });
    
   // Generate CSV report
   const modelNames = {
     'claude-3-5-haiku-20241022': 'Haiku 3.5',
     'claude-sonnet-4-20250514': 'Sonnet 4',
     'claude-opus-4-20250514': 'Opus 4'
   };
   
   let csv = '';
   
   // Header
   csv += 'Title,Model,Project,Created,Updated,Cost,Input Tokens,Output Tokens,Total Tokens\n';
   
   // Data rows
   conversations.forEach(conv => {
     const title = `"${(conv.title || 'Untitled').replace(/"/g, '""')}"`;
     const model = modelNames[conv.model] || conv.model || 'Unknown';
     const project = conv.project_name ? `"${conv.project_icon} ${conv.project_name}"` : 'Uncategorized';
     const created = new Date(conv.created_at).toLocaleDateString();
     const updated = new Date(conv.updated_at).toLocaleDateString();
     const cost = Number(conv.total_cost).toFixed(4);
     const inputTokens = conv.total_input_tokens;
     const outputTokens = conv.total_output_tokens;
     const totalTokens = inputTokens + outputTokens;
     
     csv += `${title},${model},${project},${created},${updated},${cost},${inputTokens},${outputTokens},${totalTokens}\n`;
   });
   
   // Summary
   csv += '\n';
   csv += 'SUMMARY\n';
   csv += `Total Conversations,${totalConversations}\n`;
   csv += `Total Messages,${totalMessages}\n`;
   csv += `Total Cost,${totalCost.toFixed(4)}\n`;
   csv += `Total Input Tokens,${totalInputTokens}\n`;
   csv += `Total Output Tokens,${totalOutputTokens}\n`;
   csv += `Total Tokens,${totalInputTokens + totalOutputTokens}\n`;
   csv += `Report Generated,${new Date().toLocaleString()}\n`;
   
   const filename = `claude_max_usage_report_${new Date().toISOString().split('T')[0]}.csv`;
   
   res.setHeader('Content-Type', 'text/csv');
   res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
   res.send(csv);
    
  } catch (error) {
    console.error('Usage report error:', error);
    res.status(500).json({ error: 'Failed to generate usage report' });
  }
});
module.exports = router;

const express = require('express');
const router = express.Router();
const conversationService = require('../services/conversation.service');
const claudeService = require('../services/claude.service');
const pool = require('../config/database');

// Get all conversations
router.get('/', async (req, res) => {
  try {
    const conversations = await conversationService.getAllConversations();
    res.json(conversations);
  } catch (error) {
    console.error('Error fetching conversations:', error);
    res.status(500).json({ error: error.message });
  }
});

// Create new conversation
router.post('/', async (req, res) => {
  try {
    const { title, model } = req.body;
    const conversation = await conversationService.createConversation(title || 'New Chat', model);
    res.json(conversation);
  } catch (error) {
    console.error('Error creating conversation:', error);
    res.status(500).json({ error: error.message });
  }
});

// Update conversation title
router.put('/:id/title', async (req, res) => {
  try {
    const { id } = req.params;
    const { title } = req.body;
    
    if (!title || !title.trim()) {
      return res.status(400).json({ error: 'Title is required' });
    }
    
    const conversation = await conversationService.updateConversation(id, { title: title.trim() });
    res.json(conversation);
  } catch (error) {
    console.error('Error updating conversation title:', error);
    res.status(500).json({ error: error.message });
  }
});

// Update conversation (including project assignment)
router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;
    const conversation = await conversationService.updateConversation(id, updates);
    res.json(conversation);
  } catch (error) {
    console.error('Error updating conversation:', error);
    res.status(500).json({ error: error.message });
  }
});

// PATCH route for compatibility (same as PUT)
router.patch('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;
    const conversation = await conversationService.updateConversation(id, updates);
    res.json(conversation);
  } catch (error) {
    console.error('Error updating conversation:', error);
    res.status(500).json({ error: error.message });
  }
});

// Delete conversation
router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    await conversationService.deleteConversation(id);
    res.json({ success: true });
  } catch (error) {
    console.error('Error deleting conversation:', error);
    res.status(500).json({ error: error.message });
  }
});

// Generate title from message content
router.post('/:id/generate-title', async (req, res) => {
  try {
    const { id } = req.params;
    const { content } = req.body;
    
    if (!content) {
      return res.status(400).json({ error: 'Content is required' });
    }
    
    // Use Claude to generate a short, descriptive title
    const titlePrompt = `Generate a very short, concise title (3-6 words max) for a conversation that starts with: "${content.substring(0, 200)}..."

Reply with ONLY the title, no quotes, no explanation.`;
    
    const title = await claudeService.generateTitle(titlePrompt);
    
    // Update the conversation with the new title
    const conversation = await conversationService.updateConversation(id, { title });
    
    res.json(conversation);
  } catch (error) {
    console.error('Error generating title:', error);
    res.status(500).json({ error: error.message });
  }
});

// Export conversation as Markdown or JSON
router.get('/:id/export', async (req, res) => {
  try {
    const { id } = req.params;
    const format = req.query.format || 'markdown';

    // Get conversation with metadata
    const convResult = await pool.query(
      'SELECT * FROM conversations WHERE id = $1',
      [id]
    );

    if (convResult.rows.length === 0) {
      return res.status(404).json({ error: 'Conversation not found' });
    }

    const conversation = convResult.rows[0];

    // Get all messages
    const messagesResult = await pool.query(
      'SELECT * FROM messages WHERE conversation_id = $1 ORDER BY created_at ASC',
      [id]
    );

    const messages = messagesResult.rows;

    if (format === 'json') {
      // JSON Export
      const jsonData = {
        conversation: {
          id: conversation.id,
          title: conversation.title,
          model: conversation.model,
          created_at: conversation.created_at,
          updated_at: conversation.updated_at,
          total_cost: Number(conversation.total_cost),
          total_input_tokens: conversation.total_input_tokens,
          total_output_tokens: conversation.total_output_tokens,
          project_id: conversation.project_id
        },
        messages: messages.map(msg => ({
          id: msg.id,
          role: msg.role,
          content: msg.content,
          created_at: msg.created_at,
          cost: Number(msg.cost),
          input_tokens: msg.input_tokens,
          output_tokens: msg.output_tokens
        })),
        exported_at: new Date().toISOString(),
        export_version: '1.0'
      };

      const filename = `${conversation.title.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.json`;
      
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.json(jsonData);

    } else {
      // Markdown Export
      let markdown = '';
      
      // Title and metadata
      markdown += `# ${conversation.title}\n\n`;
      markdown += `**Model:** ${conversation.model || 'N/A'}\n`;
      markdown += `**Created:** ${new Date(conversation.created_at).toLocaleString()}\n`;
      markdown += `**Updated:** ${new Date(conversation.updated_at).toLocaleString()}\n`;
      markdown += `**Total Cost:** $${Number(conversation.total_cost).toFixed(4)}\n`;
      markdown += `**Total Tokens:** ${(conversation.total_input_tokens + conversation.total_output_tokens).toLocaleString()} (${conversation.total_input_tokens.toLocaleString()} in, ${conversation.total_output_tokens.toLocaleString()} out)\n\n`;
      markdown += '---\n\n';

      // Messages
      messages.forEach((msg, index) => {
        const role = msg.role === 'user' ? 'ðŸ‘¤ User' : 'ðŸ¤– Assistant';
        const timestamp = new Date(msg.created_at).toLocaleString();
        
        markdown += `## ${role} - ${timestamp}\n\n`;
        markdown += `${msg.content}\n\n`;
        
        if (msg.cost > 0) {
          markdown += `*Cost: $${Number(msg.cost).toFixed(4)} | Tokens: ${msg.input_tokens + msg.output_tokens} (${msg.input_tokens} in, ${msg.output_tokens} out)*\n\n`;
        }
        
        markdown += '---\n\n';
      });

      const filename = `${conversation.title.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.md`;
      
      res.setHeader('Content-Type', 'text/markdown');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(markdown);
    }

  } catch (error) {
    console.error('Export error:', error);
    res.status(500).json({ error: 'Failed to export conversation' });
  }
 });
 // Bulk export all conversations in a project as ZIP
 router.get('/project/:projectId/export', async (req, res) => {
   try {
     const { projectId } = req.params;
     const format = req.query.format || 'markdown';
     
     const archiver = require('archiver');
     
     // Get project info
     const projectResult = await pool.query(
       'SELECT * FROM projects WHERE id = $1',
       [projectId]
     );
     
     if (projectResult.rows.length === 0) {
       return res.status(404).json({ error: 'Project not found' });
     }
     
     const project = projectResult.rows[0];
     
     // Get all conversations in this project
     const convsResult = await pool.query(
       'SELECT * FROM conversations WHERE project_id = $1 ORDER BY created_at DESC',
       [projectId]
     );
     
     if (convsResult.rows.length === 0) {
       return res.status(404).json({ error: 'No conversations in this project' });
     }
     
     const conversations = convsResult.rows;
     
     // Create ZIP archive
     const archive = archiver('zip', {
       zlib: { level: 9 }
     });
     
     const projectName = project.name.replace(/[^a-z0-9]/gi, '_');
     const timestamp = new Date().toISOString().split('T')[0];
     const zipFilename = `${projectName}_export_${timestamp}.zip`;
     
     res.setHeader('Content-Type', 'application/zip');
     res.setHeader('Content-Disposition', `attachment; filename="${zipFilename}"`);
     
     archive.pipe(res);
     
     // Add each conversation to the ZIP
     for (const conv of conversations) {
       // Get messages for this conversation
       const messagesResult = await pool.query(
         'SELECT * FROM messages WHERE conversation_id = $1 ORDER BY created_at ASC',
         [conv.id]
       );
       
       const messages = messagesResult.rows;
       
       if (format === 'json') {
         // JSON format
         const jsonData = {
           conversation: {
             id: conv.id,
             title: conv.title,
             model: conv.model,
             created_at: conv.created_at,
             updated_at: conv.updated_at,
             total_cost: Number(conv.total_cost),
             total_input_tokens: conv.total_input_tokens,
             total_output_tokens: conv.total_output_tokens,
             project_id: conv.project_id
           },
           messages: messages.map(msg => ({
             id: msg.id,
             role: msg.role,
             content: msg.content,
             created_at: msg.created_at,
             cost: Number(msg.cost),
             input_tokens: msg.input_tokens,
             output_tokens: msg.output_tokens
           })),
           exported_at: new Date().toISOString(),
           export_version: '1.0'
         };
         
         const filename = `${conv.title.replace(/[^a-z0-9]/gi, '_')}.json`;
         archive.append(JSON.stringify(jsonData, null, 2), { name: filename });
         
       } else {
         // Markdown format
         let markdown = '';
         
         markdown += `# ${conv.title}\n\n`;
         markdown += `**Model:** ${conv.model || 'N/A'}\n`;
         markdown += `**Created:** ${new Date(conv.created_at).toLocaleString()}\n`;
         markdown += `**Updated:** ${new Date(conv.updated_at).toLocaleString()}\n`;
         markdown += `**Total Cost:** $${Number(conv.total_cost).toFixed(4)}\n`;
         markdown += `**Total Tokens:** ${(conv.total_input_tokens + conv.total_output_tokens).toLocaleString()} (${conv.total_input_tokens.toLocaleString()} in, ${conv.total_output_tokens.toLocaleString()} out)\n\n`;
         markdown += '---\n\n';
         
         messages.forEach((msg) => {
           const role = msg.role === 'user' ? 'ðŸ‘¤ User' : 'ðŸ¤– Assistant';
           const timestamp = new Date(msg.created_at).toLocaleString();
           
           markdown += `## ${role} - ${timestamp}\n\n`;
           markdown += `${msg.content}\n\n`;
           
           if (msg.cost > 0) {
             markdown += `*Cost: $${Number(msg.cost).toFixed(4)} | Tokens: ${msg.input_tokens + msg.output_tokens} (${msg.input_tokens} in, ${msg.output_tokens} out)*\n\n`;
           }
           
           markdown += '---\n\n';
         });
         
         const filename = `${conv.title.replace(/[^a-z0-9]/gi, '_')}.md`;
         archive.append(markdown, { name: filename });
       }
     }
     
     // Add a README
     const readme = `# ${project.name} - Export\n\n` +
       `Exported: ${new Date().toLocaleString()}\n` +
       `Total Conversations: ${conversations.length}\n` +
       `Format: ${format}\n\n` +
       `## Conversations\n\n` +
       conversations.map((c, i) => `${i + 1}. ${c.title}`).join('\n');
     
     archive.append(readme, { name: 'README.md' });
     
     await archive.finalize();
     
   } catch (error) {
     console.error('Bulk export error:', error);
     res.status(500).json({ error: 'Failed to export project' });
   }
 });
// Generate global usage report
router.get('/report/usage', async (req, res) => {
  try {
    // Get all conversations with stats
    const convsResult = await pool.query(`
      SELECT 
        c.*,
        p.name as project_name,
        p.icon as project_icon
      FROM conversations c
      LEFT JOIN projects p ON c.project_id = p.id
      ORDER BY c.total_cost DESC
    `);
    
    const conversations = convsResult.rows;
    
    // Calculate totals
    const totalConversations = conversations.length;
    const totalCost = conversations.reduce((sum, c) => sum + Number(c.total_cost), 0);
    const totalInputTokens = conversations.reduce((sum, c) => sum + c.total_input_tokens, 0);
    const totalOutputTokens = conversations.reduce((sum, c) => sum + c.total_output_tokens, 0);
    
    // Get total messages count
    const messagesResult = await pool.query('SELECT COUNT(*) as count FROM messages');
    const totalMessages = parseInt(messagesResult.rows[0].count);
    
    // Group by model
    const byModel = {};
    conversations.forEach(conv => {
      const model = conv.model || 'Unknown';
      if (!byModel[model]) {
        byModel[model] = {
          conversations: 0,
          cost: 0,
          inputTokens: 0,
          outputTokens: 0
        };
      }
      byModel[model].conversations++;
      byModel[model].cost += Number(conv.total_cost);
      byModel[model].inputTokens += conv.total_input_tokens;
      byModel[model].outputTokens += conv.total_output_tokens;
    });
    
    // Group by project
    const byProject = {};
    conversations.forEach(conv => {
      const projectKey = conv.project_id || 'uncategorized';
      const projectName = conv.project_name || 'Uncategorized';
      const projectIcon = conv.project_icon || 'ðŸ“‚';
      
      if (!byProject[projectKey]) {
        byProject[projectKey] = {
          name: projectName,
          icon: projectIcon,
          conversations: 0,
          cost: 0,
          tokens: 0
        };
      }
      byProject[projectKey].conversations++;
      byProject[projectKey].cost += Number(conv.total_cost);
      byProject[projectKey].tokens += conv.total_input_tokens + conv.total_output_tokens;
    });
    
    // Generate Markdown report
    let markdown = '';
    
    markdown += `# Claude Max - Usage Report\n\n`;
    markdown += `**Generated:** ${new Date().toLocaleString()}\n\n`;
    markdown += `---\n\n`;
    
    // Overview
    markdown += `## Overview\n\n`;
    markdown += `- **Total Conversations:** ${totalConversations.toLocaleString()}\n`;
    markdown += `- **Total Messages:** ${totalMessages.toLocaleString()}\n`;
    markdown += `- **Total Cost:** $${totalCost.toFixed(4)}\n`;
    markdown += `- **Total Tokens:** ${(totalInputTokens + totalOutputTokens).toLocaleString()} (${totalInputTokens.toLocaleString()} in / ${totalOutputTokens.toLocaleString()} out)\n\n`;
    markdown += `---\n\n`;
    
    // By Model
    markdown += `## Usage by Model\n\n`;
    const modelNames = {
      'claude-3-5-haiku-20241022': 'Haiku 3.5',
      'claude-sonnet-4-20250514': 'Sonnet 4',
      'claude-opus-4-20250514': 'Opus 4'
    };
    
    Object.entries(byModel).sort((a, b) => b[1].cost - a[1].cost).forEach(([model, stats]) => {
      const displayName = modelNames[model] || model;
      markdown += `### ${displayName}\n`;
      markdown += `- **Conversations:** ${stats.conversations.toLocaleString()}\n`;
      markdown += `- **Cost:** $${stats.cost.toFixed(4)}\n`;
      markdown += `- **Tokens:** ${(stats.inputTokens + stats.outputTokens).toLocaleString()} (${stats.inputTokens.toLocaleString()} in / ${stats.outputTokens.toLocaleString()} out)\n\n`;
    });
    
    markdown += `---\n\n`;
    
    // By Project
    markdown += `## Usage by Project\n\n`;
    Object.entries(byProject).sort((a, b) => b[1].cost - a[1].cost).forEach(([key, stats]) => {
      markdown += `### ${stats.icon} ${stats.name}\n`;
      markdown += `- **Conversations:** ${stats.conversations.toLocaleString()}\n`;
      markdown += `- **Cost:** $${stats.cost.toFixed(4)}\n`;
      markdown += `- **Tokens:** ${stats.tokens.toLocaleString()}\n\n`;
    });
    
    markdown += `---\n\n`;
    
    // Top 10 Most Expensive Conversations
    markdown += `## Top 10 Most Expensive Conversations\n\n`;
    conversations.slice(0, 10).forEach((conv, idx) => {
      const modelName = modelNames[conv.model] || conv.model || 'Unknown';
      markdown += `${idx + 1}. **${conv.title}** - $${Number(conv.total_cost).toFixed(4)} - ${modelName} - ${(conv.total_input_tokens + conv.total_output_tokens).toLocaleString()} tokens\n`;
    });
    
    markdown += `\n---\n\n`;
    markdown += `*Report generated by Claude Max*\n`;
    
    const filename = `claude_max_usage_report_${new Date().toISOString().split('T')[0]}.md`;
    
    res.setHeader('Content-Type', 'text/markdown');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.send(markdown);
    
  } catch (error) {
    console.error('Usage report error:', error);
    res.status(500).json({ error: 'Failed to generate usage report' });
  }
});
module.exports = router;
